{
  "problems": [
    {
      "id": 1,
      "title": "1. Two Sum (1)",
      "url": "https://leetcode.com/problems/two-sum/",
      "topics": ["Array", "Hash Table"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Use a hash table to store numbers you've seen. For each number, check if target - number exists in your hash table."
    },
    {
      "id": 2,
      "title": "2. Add Two Numbers (2)",
      "url": "https://leetcode.com/problems/add-two-numbers/",
      "topics": ["Linked List", "Math"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Iterate through both lists, adding the digits and carrying over the sum."
    },
    {
      "id": 3,
      "title": "3. Longest Substring Without Repeating Characters (3)",
      "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/",
      "topics": ["String", "Hash Map", "Sliding Window"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use a sliding window and a hash map to keep track of the last seen index of each character."
    },
    {
      "id": 4,
      "title": "4. Longest Palindromic Substring (5)",
      "url": "https://leetcode.com/problems/longest-palindromic-substring/",
      "topics": ["String", "Dynamic Programming"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use dynamic programming or expand around the center."
    },
    {
      "id": 5,
      "title": "5. Vertical Order Traversal of a Binary Tree (987)",
      "url": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/",
      "topics": ["Binary Tree", "Traversal", "Hash Map", "Queue"],
      "difficulty": "Hard",
      "isBlind75": true,
      "hint": "Use a map to store nodes based on their horizontal distance and level. Perform a level-order traversal."
    },
    {
      "id": 6,
      "title": "6. String to Integer (atoi) (8)",
      "url": "https://leetcode.com/problems/string-to-integer-atoi/",
      "topics": ["String"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Handle leading whitespaces, sign, and overflow conditions."
    },
    {
      "id": 7,
      "title": "7. Rotting Oranges (994)",
      "url": "https://leetcode.com/problems/rotting-oranges/",
      "topics": ["BFS", "Matrix"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use BFS starting from all initially rotten oranges."
    },
    {
      "id": 8,
      "title": "8. Roman to Integer (13)",
      "url": "https://leetcode.com/problems/roman-to-integer/",
      "topics": ["String", "Hash Map"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Iterate through the Roman numeral string from right to left, adding or subtracting the value of each character based on the value of the next character."
    },
    {
      "id": 9,
      "title": "9. Longest Common Prefix (14)",
      "url": "https://leetcode.com/problems/longest-common-prefix/",
      "topics": ["String"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Iterate through the strings, comparing characters at the same index."
    },
    {
      "id": 10,
      "title": "10. 3Sum (15)",
      "url": "https://leetcode.com/problems/3sum/",
      "topics": ["Array", "Two Pointers", "Sorting"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Sort the array and use a two-pointer approach for the remaining two numbers after fixing one number."
    },
    {
      "id": 11,
      "title": "11. 4Sum (18)",
      "url": "https://leetcode.com/problems/4sum/",
      "topics": ["Array", "Two Pointers", "Sorting"],
      "difficulty": "Hard",
      "isBlind75": true,
      "hint": "Sort the array and use nested loops with two pointers."
    },
    {
      "id": 12,
      "title": "12. Remove Nth Node From End of List (19)",
      "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/",
      "topics": ["Linked List", "Two Pointers"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use two pointers, one ahead of the other by N nodes."
    },
    {
      "id": 13,
      "title": "13. Valid Parentheses (20)",
      "url": "https://leetcode.com/problems/valid-parentheses/",
      "topics": ["String", "Stack"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Use a stack. Push opening brackets onto the stack, and pop when you encounter closing brackets. Check if the popped bracket matches."
    },
    {
      "id": 14,
      "title": "14. Merge Two Sorted Lists (21)",
      "url": "https://leetcode.com/problems/merge-two-sorted-lists/",
      "topics": ["Linked List"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Use a dummy node to simplify the merging process."
    },
    {
      "id": 15,
      "title": "15. Reverse Nodes in k-Group (25)",
      "url": "https://leetcode.com/problems/reverse-nodes-in-k-group/",
      "topics": ["Linked List"],
      "difficulty": "Hard",
      "isBlind75": true,
      "hint": "Reverse groups of k nodes iteratively or recursively."
    },
    {
      "id": 16,
      "title": "16. Remove Duplicates from Sorted Array (26)",
      "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/",
      "topics": ["Array", "Two Pointers"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Use two pointers, one to iterate through the array and another to keep track of the unique elements' position."
    },
    {
      "id": 17,
      "title": "17. Construct Binary Search Tree from Preorder Traversal (1008)",
      "url": "https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/",
      "topics": ["Binary Search Tree", "Recursion", "Array"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use recursion. The first element in preorder is the root. Subsequent elements will be in the left or right subtree based on the BST property."
    },
    {
      "id": 18,
      "title": "18. Find the Index of the First Occurrence in a String (28)",
      "url": "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/",
      "topics": ["String", "Two Pointers"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Use a sliding window or the KMP algorithm."
    },
    {
      "id": 19,
      "title": "19. Next Permutation (31)",
      "url": "https://leetcode.com/problems/next-permutation/",
      "topics": ["Array"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Find the largest index k such that a[k] < a[k + 1]. If no such index exists, the permutation is the last permutation. Find the largest index l > k such that a[k] < a[l]. Swap a[k] and a[l]. Reverse the sub-array a[k + 1...n-1]."
    },
    {
      "id": 20,
      "title": "20. Diameter of Binary Tree (543)",
      "url": "https://leetcode.com/problems/diameter-of-binary-tree/",
      "topics": ["Binary Tree", "Recursion"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "The diameter can pass through the root or not. For each node, calculate the height of its left and right subtrees. The diameter through this node is height(left) + height(right)."
    },
    {
      "id": 21,
      "title": "21. Sudoku Solver (37)",
      "url": "https://leetcode.com/problems/sudoku-solver/",
      "topics": ["Backtracking", "Matrix"],
      "difficulty": "Hard",
      "isBlind75": true,
      "hint": "Use backtracking to try placing numbers in empty cells, checking for validity at each step."
    },
    {
      "id": 22,
      "title": "22. Count and Say (38)",
      "url": "https://leetcode.com/problems/count-and-say/",
      "topics": ["String"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Generate the sequence iteratively based on the previous term."
    },
    {
      "id": 23,
      "title": "23. Combination Sum (39)",
      "url": "https://leetcode.com/problems/combination-sum/",
      "topics": ["Recursion", "Backtracking"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use recursion with backtracking. Allow reusing the same number multiple times."
    },
    {
      "id": 24,
      "title": "24. Combination Sum II (40)",
      "url": "https://leetcode.com/problems/combination-sum-ii/",
      "topics": ["Recursion", "Backtracking"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use recursion with backtracking. Handle duplicates by sorting and skipping."
    },
    {
      "id": 25,
      "title": "25. Trapping Rain Water (42)",
      "url": "https://leetcode.com/problems/trapping-rain-water/",
      "topics": ["Array", "Two Pointers", "Stack"],
      "difficulty": "Hard",
      "isBlind75": true,
      "hint": "Use two pointers, one from the left and one from the right, keeping track of the maximum height seen so far on each side."
    },
    {
      "id": 26,
      "title": "26. Permutations (46)",
      "url": "https://leetcode.com/problems/permutations/",
      "topics": ["Recursion", "Backtracking"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use backtracking to generate all permutations. Keep track of used elements."
    },
    {
      "id": 27,
      "title": "27. Rotate Image (48)",
      "url": "https://leetcode.com/problems/rotate-image/",
      "topics": ["Array", "Matrix"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Transpose the matrix and then reverse each row."
    },
    {
      "id": 28,
      "title": "28. Pow(x, n) (50)",
      "url": "https://leetcode.com/problems/powx-n/",
      "topics": ["Math", "Recursion"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use binary exponentiation (exponentiation by squaring)."
    },
    {
      "id": 29,
      "title": "29. N-Queens (51)",
      "url": "https://leetcode.com/problems/n-queens/",
      "topics": ["Recursion", "Backtracking"],
      "difficulty": "Hard",
      "isBlind75": true,
      "hint": "Use backtracking to place queens column by column, checking for conflicts."
    },
    {
      "id": 30,
      "title": "30. Maximum Subarray (53)",
      "url": "https://leetcode.com/problems/maximum-subarray/",
      "topics": ["Array", "Dynamic Programming"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Keep track of the current maximum sum ending at the current position and the overall maximum sum found so far."
    },
    {
      "id": 31,
      "title": "31. Merge Intervals (56)",
      "url": "https://leetcode.com/problems/merge-intervals/",
      "topics": ["Array", "Sorting"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Sort the intervals by their start times and then merge overlapping intervals."
    },
    {
      "id": 32,
      "title": "32. Permutation Sequence (60)",
      "url": "https://leetcode.com/problems/permutation-sequence/",
      "topics": ["Math", "Recursion"],
      "difficulty": "Hard",
      "isBlind75": true,
      "hint": "Use the factorial number system to directly calculate the k-th permutation."
    },
    {
      "id": 33,
      "title": "33. Rotate List (61)",
      "url": "https://leetcode.com/problems/rotate-list/",
      "topics": ["Linked List"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Find the length of the list, make it a circular list, find the new tail and head, and break the circle."
    },
    {
      "id": 34,
      "title": "34. Unique Paths (62)",
      "url": "https://leetcode.com/problems/unique-paths/",
      "topics": ["Dynamic Programming", "Math"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use dynamic programming or combinations (nCr)."
    },
    {
      "id": 35,
      "title": "35. Minimum Path Sum (64)",
      "url": "https://leetcode.com/problems/minimum-path-sum/",
      "topics": ["Dynamic Programming", "Matrix"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use dynamic programming where dp[i][j] represents the minimum sum path to reach cell (i, j)."
    },
    {
      "id": 36,
      "title": "36. Edit Distance (72)",
      "url": "https://leetcode.com/problems/edit-distance/",
      "topics": ["Dynamic Programming", "String"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use dynamic programming where dp[i][j] represents the minimum number of operations required to convert the first i characters of word1 to the first j characters of word2."
    },
    {
      "id": 37,
      "title": "37. Set Matrix Zeroes (73)",
      "url": "https://leetcode.com/problems/set-matrix-zeroes/",
      "topics": ["Array", "Matrix"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Consider using extra space to mark rows and columns that need to be zeroed, or use the first row and column for marking."
    },
    {
      "id": 38,
      "title": "38. Search a 2D Matrix (74)",
      "url": "https://leetcode.com/problems/search-a-2d-matrix/",
      "topics": ["Array", "Matrix", "Binary Search"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Treat the 2D matrix as a sorted 1D array and apply binary search."
    },
    {
      "id": 39,
      "title": "39. Sort Colors (75)",
      "url": "https://leetcode.com/problems/sort-colors/",
      "topics": ["Array", "Two Pointers"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use a three-pointer approach (low, mid, high) to partition the array."
    },
    {
      "id": 40,
      "title": "40. Largest Rectangle in Histogram (84)",
      "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/",
      "topics": ["Stack", "Array"],
      "difficulty": "Hard",
      "isBlind75": true,
      "hint": "Use a monotonic stack to find the nearest smaller element to the left and right for each bar."
    },
    {
      "id": 41,
      "title": "41. Merge Sorted Array (88)",
      "url": "https://leetcode.com/problems/merge-sorted-array/",
      "topics": ["Array", "Two Pointers"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Merge from the end of the arrays to avoid overwriting elements."
    },
    {
      "id": 42,
      "title": "42. Subsets II (90)",
      "url": "https://leetcode.com/problems/subsets-ii/",
      "topics": ["Recursion", "Backtracking", "Array"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use backtracking. Handle duplicates by sorting the array and skipping duplicate elements."
    },
    {
      "id": 43,
      "title": "43. Binary Tree Inorder Traversal (94)",
      "url": "https://leetcode.com/problems/binary-tree-inorder-traversal/",
      "topics": ["Binary Tree", "Traversal"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Visit left subtree, then the root, then the right subtree. Can be done recursively or iteratively using a stack."
    },
    {
      "id": 44,
      "title": "44. Validate Binary Search Tree (98)",
      "url": "https://leetcode.com/problems/validate-binary-search-tree/",
      "topics": ["Binary Tree", "Binary Search Tree", "Recursion"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use recursion with a valid range (min and max) for each node's value."
    },
    {
      "id": 45,
      "title": "45. Same Tree (100)",
      "url": "https://leetcode.com/problems/same-tree/",
      "topics": ["Binary Tree", "Recursion", "Queue"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Recursively check if the current nodes and their children are the same in both trees."
    },
    {
      "id": 46,
      "title": "46. Symmetric Tree (101)",
      "url": "https://leetcode.com/problems/symmetric-tree/",
      "topics": ["Binary Tree", "Recursion", "Queue"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Check if the left subtree is a mirror image of the right subtree recursively."
    },
    {
      "id": 47,
      "title": "47. Binary Tree Level Order Traversal (102)",
      "url": "https://leetcode.com/problems/binary-tree-level-order-traversal/",
      "topics": ["Binary Tree", "Traversal", "BFS"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use a queue to perform Breadth-First Search."
    },
    {
      "id": 48,
      "title": "48. Binary Tree Zigzag Level Order Traversal (103)",
      "url": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/",
      "topics": ["Binary Tree", "Traversal", "Queue", "Stack"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use a queue or two stacks to alternate the order of processing nodes at each level."
    },
    {
      "id": 49,
      "title": "49. Maximum Depth of Binary Tree (104)",
      "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/",
      "topics": ["Binary Tree", "Recursion"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "The height of a node is 1 + the maximum of the heights of its left and right children."
    },
    {
      "id": 50,
      "title": "50. Construct Binary Tree from Preorder and Inorder Traversal (105)",
      "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",
      "topics": ["Binary Tree", "Recursion", "Array"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "The first element in preorder is the root. Find this element in inorder to determine the left and right subtrees."
    },
    {
      "id": 51,
      "title": "51. Construct Binary Tree from Inorder and Postorder Traversal (106)",
      "url": "https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/",
      "topics": ["Binary Tree", "Recursion", "Array"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "The last element in postorder is the root. Find this element in inorder to determine the left and right subtrees."
    },
    {
      "id": 52,
      "title": "52. Convert Sorted Array to Binary Search Tree (108)",
      "url": "https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/",
      "topics": ["Binary Search Tree", "Recursion", "Array"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Use the middle element of the sorted array as the root and recursively build the left and right subtrees."
    },
    {
      "id": 53,
      "title": "53. Maximum Number of Non-Overlapping Substrings (1520)",
      "url": "https://leetcode.com/problems/maximum-number-of-non-overlapping-substrings/",
      "topics": ["String", "Greedy", "Sorting"],
      "difficulty": "Hard",
      "isBlind75": true,
      "hint": "Find the first and last occurrence of each character. Identify valid substrings and then select the maximum number of non-overlapping ones greedily."
    },
    {
      "id": 54,
      "title": "54. Balanced Binary Tree (110)",
      "url": "https://leetcode.com/problems/balanced-binary-tree/",
      "topics": ["Binary Tree", "Recursion"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Recursively check if the height difference between the left and right subtrees is no more than 1 at each node."
    },
    {
      "id": 55,
      "title": "55. Flatten Binary Tree to Linked List (114)",
      "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/",
      "topics": ["Binary Tree", "Linked List"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Flatten the right subtree and then the left subtree. Connect the flattened left subtree to the right child of the root and the original right subtree to the end of the flattened left subtree."
    },
    {
      "id": 56,
      "title": "56. Populating Next Right Pointers in Each Node (116)",
      "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/",
      "topics": ["Binary Tree", "Linked List", "Queue"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use level order traversal or a recursive approach to connect nodes at the same level."
    },
    {
      "id": 57,
      "title": "57. Pascal's Triangle (118)",
      "url": "https://leetcode.com/problems/pascals-triangle/",
      "topics": ["Array", "Dynamic Programming"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Each number is the sum of the two numbers directly above it."
    },
    {
      "id": 58,
      "title": "58. Best Time to Buy and Sell Stock (121)",
      "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
      "topics": ["Array", "Dynamic Programming"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Iterate through the prices, keeping track of the minimum price seen so far and the maximum profit."
    },
    {
      "id": 59,
      "title": "59. Binary Tree Maximum Path Sum (124)",
      "url": "https://leetcode.com/problems/binary-tree-maximum-path-sum/",
      "topics": ["Binary Tree", "Recursion"],
      "difficulty": "Hard",
      "isBlind75": true,
      "hint": "Use recursion to calculate the maximum path sum starting from a node and going down. Update the overall maximum path sum at each node."
    },
    {
      "id": 60,
      "title": "60. Longest Consecutive Sequence (128)",
      "url": "https://leetcode.com/problems/longest-consecutive-sequence/",
      "topics": ["Array", "Hash Set"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use a hash set to store elements. Iterate through the elements and check if the previous number exists in the set to identify the start of a sequence."
    },
    {
      "id": 61,
      "title": "61. Palindrome Partitioning (131)",
      "url": "https://leetcode.com/problems/palindrome-partitioning/",
      "topics": ["Recursion", "Backtracking", "String"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use backtracking to explore all possible partitions and check if each partition is a palindrome."
    },
    {
      "id": 62,
      "title": "62. Clone Graph (133)",
      "url": "https://leetcode.com/problems/clone-graph/",
      "topics": ["Graph", "BFS", "DFS", "Hash Map"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use BFS or DFS to traverse the graph and a hash map to store the mapping from original nodes to cloned nodes."
    },
    {
      "id": 63,
      "title": "63. Set Mismatch (645)",
      "url": "https://leetcode.com/problems/set-mismatch/",
      "topics": ["Array", "Hash Map", "Math"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Use a frequency array/hash map or mathematical properties (sum and sum of squares)."
    },
    {
      "id": 64,
      "title": "64. Minimum Cost to Cut a Stick (1547)",
      "url": "https://leetcode.com/problems/minimum-cost-to-cut-a-stick/",
      "topics": ["Dynamic Programming", "Recursion"],
      "difficulty": "Hard",
      "isBlind75": true,
      "hint": "Use dynamic programming with memoization. Consider each possible cut point as the last cut."
    },
    {
      "id": 65,
      "title": "65. Copy List with Random Pointer (138)",
      "url": "https://leetcode.com/problems/copy-list-with-random-pointer/",
      "topics": ["Linked List", "Hash Map"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use a hash map to store the mapping from original nodes to copied nodes, or interweave the copied nodes with the original nodes."
    },
    {
      "id": 66,
      "title": "66. Linked List Cycle (141)",
      "url": "https://leetcode.com/problems/linked-list-cycle/",
      "topics": ["Linked List", "Two Pointers"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Use Floyd's Tortoise and Hare algorithm (slow and fast pointers)."
    },
    {
      "id": 67,
      "title": "67. Linked List Cycle II (142)",
      "url": "https://leetcode.com/problems/linked-list-cycle-ii/",
      "topics": ["Linked List", "Two Pointers"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "After finding the meeting point with Floyd's algorithm, move one pointer to the head and keep the other at the meeting point. Move both one step at a time until they meet."
    },
    {
      "id": 68,
      "title": "68. Two Sum IV - Input is a BST (653)",
      "url": "https://leetcode.com/problems/two-sum-iv-input-is-a-bst/",
      "topics": ["Binary Search Tree", "Hash Set", "Two Pointers"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Use a hash set to store visited node values. For each node, check if `sum - node.val` exists in the set. Alternatively, convert the BST to a sorted array and use two pointers."
    },
    {
      "id": 69,
      "title": "69. Binary Tree Preorder Traversal (144)",
      "url": "https://leetcode.com/problems/binary-tree-preorder-traversal/",
      "topics": ["Binary Tree", "Traversal"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Visit the root, then the left subtree, then the right subtree. Can be done recursively or iteratively using a stack."
    },
    {
      "id": 70,
      "title": "70. Binary Tree Postorder Traversal (145)",
      "url": "https://leetcode.com/problems/binary-tree-postorder-traversal/",
      "topics": ["Binary Tree", "Traversal"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Visit left subtree, then the right subtree, then the root. Can be done recursively or iteratively using two stacks."
    },
    {
      "id": 71,
      "title": "71. LRU Cache (146)",
      "url": "https://leetcode.com/problems/lru-cache/",
      "topics": ["Design", "Hash Map", "Linked List"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use a hash map and a doubly linked list to implement the LRU cache."
    },
    {
      "id": 72,
      "title": "72. Maximum Width of Binary Tree (662)",
      "url": "https://leetcode.com/problems/maximum-width-of-binary-tree/",
      "topics": ["Binary Tree", "Traversal", "Queue"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use level order traversal and assign indices to nodes to calculate the width at each level."
    },
    {
      "id": 73,
      "title": "73. Reverse Words in a String (151)",
      "url": "https://leetcode.com/problems/reverse-words-in-a-string/",
      "topics": ["String"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Trim leading/trailing spaces, split the string into words, reverse the order of words, and join them with a single space."
    },
    {
      "id": 74,
      "title": "74. Maximum Product Subarray (152)",
      "url": "https://leetcode.com/problems/maximum-product-subarray/",
      "topics": ["Array", "Dynamic Programming"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Keep track of the maximum and minimum product ending at the current position."
    },
    {
      "id": 75,
      "title": "75. Min Stack (155)",
      "url": "https://leetcode.com/problems/min-stack/",
      "topics": ["Stack", "Design"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use an auxiliary stack to keep track of the minimum element at each level of the main stack."
    },
    {
      "id": 76,
      "title": "76. Intersection of Two Linked Lists (160)",
      "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/",
      "topics": ["Linked List", "Two Pointers"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Use two pointers, moving them to the head of the other list when they reach the end of their current list."
    },
    {
      "id": 77,
      "title": "77. Compare Version Numbers (165)",
      "url": "https://leetcode.com/problems/compare-version-numbers/",
      "topics": ["String", "Two Pointers"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Split the version strings by '.' and compare the corresponding integer revisions."
    },
    {
      "id": 78,
      "title": "78. Majority Element (169)",
      "url": "https://leetcode.com/problems/majority-element/",
      "topics": ["Array", "Counting", "Boyer-Moore Majority Vote Algorithm"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Use Boyer-Moore Majority Vote Algorithm: maintain a candidate and a counter."
    },
    {
      "id": 79,
      "title": "79. Binary Search Tree Iterator (173)",
      "url": "https://leetcode.com/problems/binary-search-tree-iterator/",
      "topics": ["Binary Search Tree", "Design", "Stack"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use a stack to store the left spine of the current node. When `next()` is called, pop from the stack, process the node, and push the left spine of its right child."
    },
    {
      "id": 80,
      "title": "80. Repeated String Match (686)",
      "url": "https://leetcode.com/problems/repeated-string-match/",
      "topics": ["String"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Repeat string 'a' until its length is at least the length of 'b'. Check if 'b' is a substring. If not, append 'a' one more time and check again."
    },
    {
      "id": 81,
      "title": "81. Number of Islands (200)",
      "url": "https://leetcode.com/problems/number-of-islands/",
      "topics": ["Graph", "DFS", "BFS", "Matrix"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Traverse the grid. When you find a '1', increment the island count and use DFS or BFS to mark all connected '1's as visited."
    },
    {
      "id": 82,
      "title": "82. Reverse Linked List (206)",
      "url": "https://leetcode.com/problems/reverse-linked-list/",
      "topics": ["Linked List"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Iterate through the list, changing the next pointer of each node to point to its previous node."
    },
    {
      "id": 83,
      "title": "83. Course Schedule (207)",
      "url": "https://leetcode.com/problems/course-schedule/",
      "topics": ["Graph", "Topological Sort"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Build a directed graph representing prerequisites. Check for cycles using topological sort (Kahn's algorithm or DFS)."
    },
    {
      "id": 84,
      "title": "84. Implement Trie (Prefix Tree) (208)",
      "url": "https://leetcode.com/problems/implement-trie-prefix-tree/",
      "topics": ["Trie", "Design"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Implement the Trie data structure with insert, search, and startsWith operations."
    },
    {
      "id": 85,
      "title": "85. Kth Largest Element in an Array (215)",
      "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/",
      "topics": ["Heap", "Sorting", "Divide and Conquer"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use a min-heap of size k, or use QuickSelect algorithm."
    },
    {
      "id": 86,
      "title": "86. Flood Fill (733)",
      "url": "https://leetcode.com/problems/flood-fill/",
      "topics": ["DFS", "BFS", "Matrix"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Use DFS or BFS to traverse the connected components of the starting pixel and change their color."
    },
    {
      "id": 87,
      "title": "87. Implement Stack using Queues (225)",
      "url": "https://leetcode.com/problems/implement-stack-using-queues/",
      "topics": ["Stack", "Queue"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Use one or two queues to simulate stack operations."
    },
    {
      "id": 88,
      "title": "88. Longest Common Subsequence (1143)",
      "url": "https://leetcode.com/problems/longest-common-subsequence/",
      "topics": ["Dynamic Programming", "String"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use dynamic programming to build a table where dp[i][j] represents the length of the LCS of the first i characters of string1 and the first j characters of string2."
    },
    {
      "id": 89,
      "title": "89. Majority Element II (229)",
      "url": "https://leetcode.com/problems/majority-element-ii/",
      "topics": ["Array", "Counting"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Extend Boyer-Moore to find up to two majority elements."
    },
    {
      "id": 90,
      "title": "90. Kth Smallest Element in a BST (230)",
      "url": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/",
      "topics": ["Binary Search Tree", "Traversal"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Perform an inorder traversal and keep a count of visited nodes. The K-th node visited is the K-th smallest."
    },
    {
      "id": 91,
      "title": "91. Implement Queue using Stacks (232)",
      "url": "https://leetcode.com/problems/implement-queue-using-stacks/",
      "topics": ["Queue", "Stack"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Use two stacks to simulate queue operations."
    },
    {
      "id": 92,
      "title": "92. Palindrome Linked List (234)",
      "url": "https://leetcode.com/problems/palindrome-linked-list/",
      "topics": ["Linked List", "Two Pointers", "Stack"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Reverse the second half of the linked list and compare it with the first half, or use a stack."
    },
    {
      "id": 93,
      "title": "93. Lowest Common Ancestor of a Binary Search Tree (235)",
      "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",
      "topics": ["Binary Search Tree", "Recursion"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use the BST property: if both nodes are smaller than the current node, search in the left subtree; if both are larger, search in the right subtree; otherwise, the current node is the LCA."
    },
    {
      "id": 94,
      "title": "94. Lowest Common Ancestor of a Binary Tree (236)",
      "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/",
      "topics": ["Binary Tree", "Recursion"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Recursively search for the two nodes. If both are found in different subtrees, the current node is the LCA. If one is found, that node is the LCA (assuming the other is in its subtree)."
    },
    {
      "id": 95,
      "title": "95. Delete Node in a Linked List (237)",
      "url": "https://leetcode.com/problems/delete-node-in-a-linked-list/",
      "topics": ["Linked List"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Copy the value of the next node to the current node and delete the next node."
    },
    {
      "id": 96,
      "title": "96. Sliding Window Maximum (239)",
      "url": "https://leetcode.com/problems/sliding-window-maximum/",
      "topics": ["Queue", "Array", "Sliding Window"],
      "difficulty": "Hard",
      "isBlind75": true,
      "hint": "Use a deque (double-ended queue) to store indices of elements in the current window in decreasing order of their values."
    },
    {
      "id": 97,
      "title": "97. Valid Anagram (242)",
      "url": "https://leetcode.com/problems/valid-anagram/",
      "topics": ["String", "Hash Map", "Sorting"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Use a hash map to count character frequencies or sort both strings and compare them."
    },
    {
      "id": 98,
      "title": "98. Search in a Binary Search Tree (700)",
      "url": "https://leetcode.com/problems/search-in-a-binary-search-tree/",
      "topics": ["Binary Search Tree", "Recursion"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Use the BST property to efficiently search for the key."
    },
    {
      "id": 99,
      "title": "99. Kth Largest Element in a Stream (703)",
      "url": "https://leetcode.com/problems/kth-largest-element-in-a-stream/",
      "topics": ["Heap", "Design"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Use a min-heap of size k to store the k largest elements."
    },
    {
      "id": 100,
      "title": "100. Find the Duplicate Number (287)",
      "url": "https://leetcode.com/problems/find-the-duplicate-number/",
      "topics": ["Array", "Two Pointers", "Linked List Cycle (Floyd's Tortoise and Hare)"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Treat the array as a linked list and find the cycle detection point."
    },
    {
      "id": 101,
      "title": "101. Is Graph Bipartite? (785)",
      "url": "https://leetcode.com/problems/is-graph-bipartite/",
      "topics": ["Graph", "BFS", "DFS"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use BFS or DFS to color the graph with two colors. If you encounter an edge connecting two nodes of the same color, the graph is not bipartite."
    },
    {
      "id": 102,
      "title": "102. Maximum XOR With an Element From Array (1707)",
      "url": "https://leetcode.com/problems/maximum-xor-with-an-element-from-array/",
      "topics": ["Trie", "Bit Manipulation", "Sorting"],
      "difficulty": "Hard",
      "isBlind75": true,
      "hint": "Sort the array and queries. Use a Trie to store the numbers encountered so far and query for the maximum XOR value for each query."
    },
    {
      "id": 103,
      "title": "103. Find Median from Data Stream (295)",
      "url": "https://leetcode.com/problems/find-median-from-data-stream/",
      "topics": ["Heap"],
      "difficulty": "Hard",
      "isBlind75": true,
      "hint": "Use two heaps, a max-heap for the lower half of the numbers and a min-heap for the upper half."
    },
    {
      "id": 104,
      "title": "104. Serialize and Deserialize Binary Tree (297)",
      "url": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/",
      "topics": ["Binary Tree", "Design", "Queue"],
      "difficulty": "Hard",
      "isBlind75": true,
      "hint": "Use BFS (level order traversal) to serialize the tree into a string, including null nodes. Use the same approach to deserialize."
    },
    {
      "id": 105,
      "title": "105. Longest Increasing Subsequence (300)",
      "url": "https://leetcode.com/problems/longest-increasing-subsequence/",
      "topics": ["Dynamic Programming", "Binary Search"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use dynamic programming where dp[i] is the length of the LIS ending at index i. Alternatively, use a dynamic programming approach with binary search to find the smallest tail of all increasing subsequences of length k."
    },
    {
      "id": 106,
      "title": "106. Coin Change (322)",
      "url": "https://leetcode.com/problems/coin-change/",
      "topics": ["Dynamic Programming", "Array"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use dynamic programming where dp[i] represents the minimum number of coins required to make amount i."
    },
    {
      "id": 107,
      "title": "107. Top K Frequent Elements (347)",
      "url": "https://leetcode.com/problems/top-k-frequent-elements/",
      "topics": ["Hash Map", "Heap", "Sorting"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use a hash map to count frequencies and a min-heap of size k to keep track of the top k frequent elements."
    },
    {
      "id": 108,
      "title": "108. Middle of the Linked List (876)",
      "url": "https://leetcode.com/problems/middle-of-the-linked-list/",
      "topics": ["Linked List", "Two Pointers"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Use two pointers, a slow pointer and a fast pointer. Move the fast pointer two steps at a time and the slow pointer one step at a time."
    },
    {
      "id": 109,
      "title": "109. Partition Equal Subset Sum (416)",
      "url": "https://leetcode.com/problems/partition-equal-subset-sum/",
      "topics": ["Dynamic Programming", "Array"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "This is a variation of the subset sum problem. Check if a subset with sum equal to half of the total sum exists."
    },
    {
      "id": 110,
      "title": "110. Maximum XOR of Two Numbers in an Array (421)",
      "url": "https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/",
      "topics": ["Trie", "Bit Manipulation"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use a Trie (prefix tree) to store the binary representations of the numbers. For each number, try to find a number in the Trie that maximizes the XOR value."
    },
    {
      "id": 111,
      "title": "111. Online Stock Span (901)",
      "url": "https://leetcode.com/problems/stock-span-problem/",
      "topics": ["Stack", "Array"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "Use a monotonic stack to keep track of previous elements less than or equal to the current element."
    },
    {
      "id": 112,
      "title": "112. Maximum Sum BST in Binary Tree (1373)",
      "url": "https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/",
      "topics": ["Binary Tree", "Binary Search Tree", "Recursion"],
      "difficulty": "Hard",
      "isBlind75": true,
      "hint": "Use recursion to return information from children: whether the subtree is a BST, its sum, minimum value, and maximum value."
    },
    {
      "id": 113,
      "title": "113. LFU Cache (460)",
      "url": "https://leetcode.com/problems/lfu-cache/",
      "topics": ["Design", "Hash Map", "Linked List"],
      "difficulty": "Hard",
      "isBlind75": true,
      "hint": "Use a combination of hash maps and doubly linked lists to track frequency and recency."
    },
    {
      "id": 114,
      "title": "114. Ones and Zeroes (474)",
      "url": "https://leetcode.com/problems/ones-and-zeroes/",
      "topics": ["Dynamic Programming", "Array"],
      "difficulty": "Medium",
      "isBlind75": true,
      "hint": "This is a variation of the knapsack problem. Use dynamic programming where dp[i][j] represents the maximum number of strings that can be formed with i zeros and j ones."
    },
    {
      "id": 115,
      "title": "115. Max Consecutive Ones (485)",
      "url": "https://leetcode.com/problems/max-consecutive-ones/",
      "topics": ["Array"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Iterate through the array, counting consecutive ones and updating the maximum count."
    },
    {
      "id": 116,
      "title": "116. Reverse Pairs (493)",
      "url": "https://leetcode.com/problems/reverse-pairs/",
      "topics": ["Array", "Divide and Conquer", "Merge Sort"],
      "difficulty": "Hard",
      "isBlind75": true,
      "hint": "Count reverse pairs during the merge step of merge sort with a slight modification."
    },
    {
      "id": 117,
      "title": "117. Next Greater Element I (496)",
      "url": "https://leetcode.com/problems/next-greater-element-i/",
      "topics": ["Stack", "Array"],
      "difficulty": "Easy",
      "isBlind75": true,
      "hint": "Use a monotonic stack to keep track of elements for which the next greater element has not been found yet."
    }
  ]
}
